{"version":3,"sources":["util.js"],"names":["define","$","eventer","Util","TRANSITION_END","[object Object]","prefix","Math","random","document","getElementById","element","selector","getAttribute","hrefAttr","trim","querySelector","transitionDuration","css","transitionDelay","floatTransitionDuration","parseFloat","floatTransitionDelay","split","reflow","offsetHeight","trigger","supportsTransitionEnd","Boolean","isElement","obj","nodeType","componentName","config","configTypes","property","Object","prototype","hasOwnProperty","call","expectedTypes","value","valueType","toString","match","toLowerCase","RegExp","test","Error","toUpperCase","documentElement","attachShadow","getRootNode","root","ShadowRoot","parentNode","findShadowRoot","special","bsTransitionEnd","transitionEnd"],"mappings":";;;;;;;AAAAA,QACI,0BACA,6BACD,SAAUC,EAAGC,GACZ,aA0CA,MAAMC,GACFC,eAAgB,kBAEhBC,OAAOC,GACH,GACIA,MA5CI,IA4CSC,KAAKC,gBACbC,SAASC,eAAeJ,IACjC,OAAOA,GAGXD,uBAAuBM,GACnB,IAAIC,EAAWD,EAAQE,aAAa,eACpC,IAAKD,GAAyB,MAAbA,EAAkB,CAC/B,MAAME,EAAWH,EAAQE,aAAa,QACtCD,EAAWE,GAAyB,MAAbA,EAAmBA,EAASC,OAAS,GAEhE,OAAOH,GAAYH,SAASO,cAAcJ,GAAYA,EAAW,MAGrEP,iCAAiCM,GAC7B,IAAKA,EACD,OAAO,EAEX,IAAIM,EAAqBhB,EAAEU,GAASO,IAAI,uBACpCC,EAAkBlB,EAAEU,GAASO,IAAI,oBACrC,MAAME,EAA0BC,WAAWJ,GACrCK,EAAuBD,WAAWF,GACxC,OAAKC,GAA4BE,GAGjCL,EAAqBA,EAAmBM,MAAM,KAAK,GACnDJ,EAAkBA,EAAgBI,MAAM,KAAK,GArErB,KAsEhBF,WAAWJ,GAAsBI,WAAWF,KAJzC,GAOfK,OAAOb,GACIA,EAAQc,aAGnBpB,qBAAqBM,GACjBV,EAAEU,GAASe,QAhFI,kBAmFnBC,sBAAqB,IACVC,QApFQ,iBAuFnBC,UAAUC,IACEA,EAAI,IAAMA,GAAKC,SAG3B1B,gBAAgB2B,EAAeC,EAAQC,GACnC,IAAK,MAAMC,KAAYD,EACnB,GAAIE,OAAOC,UAAUC,eAAeC,KAAKL,EAAaC,GAAW,CAC7D,MAAMK,EAAgBN,EAAYC,GAC5BM,EAAQR,EAAOE,GACfO,EAAYD,GAAStC,EAAK0B,UAAUY,GAAS,WA5FnDX,EA4FsEW,KA3FxEE,SAASJ,KAAKT,GAAKc,MAAM,eAAe,GAAGC,eA4FzC,IAAK,IAAIC,OAAON,GAAeO,KAAKL,GAChC,MAAM,IAAIM,SAAUhB,EAAciB,6BAAiCd,qBAA8BO,4BAAwCF,OA9F7J,IAAgBV,GAoGZzB,eAAeM,GACX,IAAKF,SAASyC,gBAAgBC,aAC1B,OAAO,KAEX,GAAmC,mBAAxBxC,EAAQyC,YAA4B,CAC3C,MAAMC,EAAO1C,EAAQyC,cACrB,OAAOC,aAAgBC,WAAaD,EAAO,KAE/C,OAAI1C,aAAmB2C,WACZ3C,EAENA,EAAQ4C,WAGNpD,EAAKqD,eAAe7C,EAAQ4C,YAFxB,OASnB,OAFArD,EAAQuD,QAAQC,gBAAkBxD,EAAQuD,QAAQE,cAE3CxD","file":"../util.js","sourcesContent":["define([\n    'skylark-utils-dom/query',\n    'skylark-utils-dom/eventer'\n], function ($, eventer) {\n    'use strict';\n\n    const TRANSITION_END = 'transitionend';\n    const MAX_UID = 1000000;\n    const MILLISECONDS_MULTIPLIER = 1000;\n\n    function toType(obj) {\n        return {}.toString.call(obj).match(/\\s([a-z]+)/i)[1].toLowerCase();\n    }\n\n    /*\n    function getSpecialTransitionEndEvent() {\n        return {\n            bindType: TRANSITION_END,\n            delegateType: TRANSITION_END,\n            handle(event) {\n                if ($(event.target).is(this)) {\n                    return event.handleObj.handler.apply(this, arguments);\n                }\n                return undefined;\n            }\n        };\n    }\n\n    function transitionEndEmulator(duration) {\n        let called = false;\n        $(this).one(Util.TRANSITION_END, () => {\n            called = true;\n        });\n        setTimeout(() => {\n            if (!called) {\n                Util.triggerTransitionEnd(this);\n            }\n        }, duration);\n        return this;\n    }\n\n    function setTransitionEndSupport() {\n        $.fn.emulateTransitionEnd = transitionEndEmulator;\n        eventer.create.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();\n    }\n    */\n    const Util = {\n        TRANSITION_END: 'bsTransitionEnd',\n\n        getUID(prefix) {\n            do {\n                prefix += ~~(Math.random() * MAX_UID);\n            } while (document.getElementById(prefix));\n            return prefix;\n        },\n\n        getSelectorFromElement(element) {\n            let selector = element.getAttribute('data-target');\n            if (!selector || selector === '#') {\n                const hrefAttr = element.getAttribute('href');\n                selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : '';\n            }\n            return selector && document.querySelector(selector) ? selector : null;\n        },\n\n        getTransitionDurationFromElement(element) {\n            if (!element) {\n                return 0;\n            }\n            let transitionDuration = $(element).css('transition-duration');\n            let transitionDelay = $(element).css('transition-delay');\n            const floatTransitionDuration = parseFloat(transitionDuration);\n            const floatTransitionDelay = parseFloat(transitionDelay);\n            if (!floatTransitionDuration && !floatTransitionDelay) {\n                return 0;\n            }\n            transitionDuration = transitionDuration.split(',')[0];\n            transitionDelay = transitionDelay.split(',')[0];\n            return (parseFloat(transitionDuration) + parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;\n        },\n\n        reflow(element) {\n            return element.offsetHeight;\n        },\n\n        triggerTransitionEnd(element) {\n            $(element).trigger(TRANSITION_END);\n        },\n\n        supportsTransitionEnd() {\n            return Boolean(TRANSITION_END);\n        },\n\n        isElement(obj) {\n            return (obj[0] || obj).nodeType;\n        },\n\n        typeCheckConfig(componentName, config, configTypes) {\n            for (const property in configTypes) {\n                if (Object.prototype.hasOwnProperty.call(configTypes, property)) {\n                    const expectedTypes = configTypes[property];\n                    const value = config[property];\n                    const valueType = value && Util.isElement(value) ? 'element' : toType(value);\n                    if (!new RegExp(expectedTypes).test(valueType)) {\n                        throw new Error(`${ componentName.toUpperCase() }: ` + `Option \"${ property }\" provided type \"${ valueType }\" ` + `but expected type \"${ expectedTypes }\".`);\n                    }\n                }\n            }\n        },\n\n        findShadowRoot(element) {\n            if (!document.documentElement.attachShadow) {\n                return null;\n            }\n            if (typeof element.getRootNode === 'function') {\n                const root = element.getRootNode();\n                return root instanceof ShadowRoot ? root : null;\n            }\n            if (element instanceof ShadowRoot) {\n                return element;\n            }\n            if (!element.parentNode) {\n                return null;\n            }\n            return Util.findShadowRoot(element.parentNode);\n        }\n    };\n\n    //setTransitionEndSupport();\n    eventer.special.bsTransitionEnd = eventer.special.transitionEnd;\n\n    return Util;\n});"]}